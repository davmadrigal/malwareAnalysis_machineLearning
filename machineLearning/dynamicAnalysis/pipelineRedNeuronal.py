import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import (accuracy_score, confusion_matrix, classification_report,
                             precision_score, recall_score, f1_score, roc_curve, precision_recall_curve, auc)
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping
import sys
# Ruta al dataset
PATH = "./datasetNoBalancedMoreGoodware.csv"

def load_data(path=PATH):
    """Cargar el dataset desde la ruta especificada"""
    return pd.read_csv(path)

def preprocess_data(data):
    """Preprocesar los datos eliminando columnas innecesarias y convirtiendo tipos de datos"""
    data_no_name = data.drop(data.columns[[0,1]], axis=1)
    return data_no_name

def split_data(data):
    """Dividir los datos en conjuntos de entrenamiento y prueba."""
    x = data.drop('3', axis=1)  # removing family type
    y = data['3']

    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)
    return x_train, x_test, y_train, y_test

def create_model(input_shape):
    """Crear el modelo de red neuronal"""
    model = keras.Sequential()
    model.add(layers.Dense(256, activation='relu', input_shape=(input_shape,)))
    model.add(layers.Dense(1, activation='sigmoid'))  # Capa de salida
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

def plot_confusion_matrix(cm):
    """Plot the confusion matrix"""
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.imshow(cm, cmap='Pastel1')
    ax.grid(False)
    ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Goodware(0)', 'Predicted Malware(1)'))
    ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual Goodware(0)', 'Actual Malware(1)'))
    ax.set_ylim(1.5, -0.5)

    for i in range(2):
        for j in range(2):
            ax.text(j, i, cm[i, j], ha='center', va='center', color="red")
    plt.show()

def plot_roc_curve(fpr, tpr):
    """Plot the ROC curve"""
    plt.plot(fpr, tpr, linewidth=2)
    plt.plot([0, 1], [0, 1], 'k--')
    plt.axis([0, 1, 0, 1])
    plt.xlabel('FPR', fontsize=16)
    plt.ylabel('TPR', fontsize=16)
    plt.grid(True)
    plt.show()


def plot_pr_curve(precision, recall):
    """Plot the Precision-Recall curve"""
    plt.figure(figsize=(8, 6))
    plt.plot(recall, precision, linewidth=2)
    plt.xlabel('Recall', fontsize=14)
    plt.ylabel('Precision', fontsize=14)
    plt.grid(True)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.title('Precision-Recall Curve', fontsize=16)
    plt.show()

def main():
    """FunciÃ³n principal para ejecutar el flujo de trabajo"""
    data = load_data()
    processed_data = preprocess_data(data)
    x_train, x_test, y_train, y_test = split_data(processed_data)
    y_train = y_train.to_numpy()
    # Normalizar los datos
    scaler = StandardScaler()
    x_train = scaler.fit_transform(x_train)
    x_test = scaler.transform(x_test)
    
    # Configurar el callback EarlyStopping
    early_stopping = EarlyStopping(monitor='val_loss', patience=30, restore_best_weights=True)

    # Crear y entrenar el modelo
    model = create_model(x_train.shape[1])
    model.fit(x_train, 
            y_train, 
            epochs=50, 
            batch_size=32,
            class_weight = {0:1, 1:1.666}, 
            validation_split=0.2, 
            callbacks=[early_stopping])

    # Hacer predicciones
    preds = (model.predict(x_test) > 0.5).astype("int32")
    
    # Evaluar el modelo
    test_accuracy = accuracy_score(y_test, preds)
    print("Test accuracy:", test_accuracy)
    
    cm = confusion_matrix(y_test, preds)
    print("Confusion Matrix:\n", cm)
    plot_confusion_matrix(cm)
    
    print("Classification Report:\n", classification_report(y_test, preds, digits=5))
    print("Precision score:", precision_score(y_test, preds))
    print("Recall score:", recall_score(y_test, preds))
    print("F1 score:", f1_score(y_test, preds))
    
    fpr, tpr, _ = roc_curve(y_test, preds)
    plot_roc_curve(fpr, tpr)

    precision, recall, _ = precision_recall_curve(y_test, preds)
    plot_pr_curve(precision, recall)
    auc_pr = auc(recall, precision)
    print("AUC-PR:", auc_pr)

if __name__ == "__main__":
    main()

