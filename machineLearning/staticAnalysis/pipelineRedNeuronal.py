import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import (accuracy_score, confusion_matrix, classification_report,
                             precision_score, recall_score, f1_score, roc_curve, precision_recall_curve, auc)
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping

# Ruta al dataset
PATH = "./DatasetNoBalancedMoreGoodware.csv"

def load_data(path=PATH):
    """Load the dataset from the specified path"""
    return pd.read_csv(path)

def preprocess_data(data):
    """Preprocess the data by removing unnecessary columns and converting data types"""
    data_no_name = data.drop(data.columns[0], axis=1)
    data_no_name_no_empty = data_no_name.replace('', '0')
    data_no_name_no_empty = data_no_name_no_empty.apply(pd.to_numeric, errors='coerce')
    return data_no_name_no_empty

def split_data(data):
    """Split the data into training and test sets."""
    x = data.drop('2', axis=1)  # remove family type 
    y = data['2']
    return train_test_split(x, y, test_size=0.3, random_state=42)

def create_model(input_shape):
    """Create de model"""
    model = keras.Sequential()
    model.add(layers.Dense(32, activation='relu', input_shape=(input_shape,)))  # Input and hidden layer
    model.add(layers.Dense(1, activation='sigmoid'))  # Output
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

def plot_confusion_matrix(cm):
    """Plot the confusion matrix"""
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.imshow(cm, cmap='Pastel1')
    ax.grid(False)
    ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Goodware(0)', 'Predicted Malware(1)'))
    ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual Goodware(0)', 'Actual Malware(1)'))
    ax.set_ylim(1.5, -0.5)

    for i in range(2):
        for j in range(2):
            ax.text(j, i, cm[i, j], ha='center', va='center', color="red")
    plt.show()

def plot_roc_curve(fpr, tpr):
    """Plot the ROC curve"""
    plt.plot(fpr, tpr, linewidth=2)
    plt.plot([0, 1], [0, 1], 'k--')
    plt.axis([0, 1, 0, 1])
    plt.xlabel('FPR', fontsize=16)
    plt.ylabel('TPR', fontsize=16)
    plt.grid(True)
    plt.show()


def plot_pr_curve(precision, recall):
    """Plot the Precision-Recall curve"""
    plt.figure(figsize=(8, 6))
    plt.plot(recall, precision, linewidth=2)
    plt.xlabel('Recall', fontsize=14)
    plt.ylabel('Precision', fontsize=14)
    plt.grid(True)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.title('Precision-Recall Curve', fontsize=16)
    plt.show()

def main():
    """main flow"""
    data = load_data()
    processed_data = preprocess_data(data)
    x_train, x_test, y_train, y_test = split_data(processed_data)
 
    scaler = StandardScaler()
    x_train = scaler.fit_transform(x_train)
    x_test = scaler.transform(x_test)

    y_train = y_train.to_numpy()
    
    # Configure callback EarlyStopping
    early_stopping = EarlyStopping(monitor='val_loss', patience=30, restore_best_weights=True)

    # Create and train the model
    model = create_model(x_train.shape[1])
    model.fit(x_train, 
             y_train, 
             epochs=50, 
             batch_size=32, 
             validation_split=0.2,
             class_weight = {0: 1.0, 1: 1.666},
             callbacks=[early_stopping])

    # predictions
    preds = (model.predict(x_test) > 0.5).astype("int32")
    
    # Eval the model
    test_accuracy = accuracy_score(y_test, preds)
    print("Test accuracy:", test_accuracy)
    
    cm = confusion_matrix(y_test, preds)
    print("Confusion Matrix:\n", cm)
    plot_confusion_matrix(cm)
    
    print("Classification Report:\n", classification_report(y_test, preds, digits=5))
    print("Precision score:", precision_score(y_test, preds))
    print("Recall score:", recall_score(y_test, preds))
    print("F1 score:", f1_score(y_test, preds))
    
    fpr, tpr, _ = roc_curve(y_test, preds)
    plot_roc_curve(fpr, tpr)

    precision, recall, _ = precision_recall_curve(y_test, preds)
    plot_pr_curve(precision, recall)
    auc_pr = auc(recall, precision)
    print("AUC-PR:", auc_pr)

if __name__ == "__main__":
    main()

